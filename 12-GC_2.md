# 垃圾回收（下）

*大部分Java对象只存活一小段时间，而存活下来的小部分Java对象则会存活很长一段时间。*

这个假设造就了JVM的分代回收思想。简单来说，就是将堆空间划分为两代，分别叫做新声代和老年代。新生代用来存储新建的对象。当对象存活时间够长时，则将其移动到老年代。

## JVM的堆划分

JVM将堆划分为新生代和老生代。其中，新生代又被划分为Eden区，以及两个大小相同的Survivor区。

当调用new指令时，它会在Eden区中划出一块作为存储对象的内存。当Eden区的空间耗尽了，JVM便会触发一次Minor GC，来收集新生代的垃圾。存活下来的对象，则会被送到Survivor区。

新生代共有两个Survivor区，分别用from和to来指代。其中to指向的Survivor区是空的。

当发生Minor GC时，Eden区和from指向的Survivor区中的存活对象会被复制到to指向的Survivor区中，然后交换from和to指针，以保证下一次Minor GC时，to指向的Survivor区还是空的。

JVM会记录Survivor区中的对象一共被来回复制了几次。如果一个对象被复制的次数为15（JVM参数：-XX:+MaxTenuringThreshold），那么该对象将被晋升至老年代。另外，如果单个Survivor区已经被占用了50%（JVM参数：-XX:TargetSurvivorRatio），那么较高复制次数的对象也会被晋升至老年代。

## 卡表

老年代的对象可能引用新生代的对象。也就是说，在标记存活对象的时候，需要扫描老年代中的对象。如果该对象拥有对新生代对象的引用，那么这个引用也会被作为GC Roots。这样，岂不是又做了一次全堆扫描？

HotSpot给出的解决方案是一项叫做卡表（Card Table）的技术。该技术将整个堆划分为一个个大小为512字节的卡，并且维护一个卡表，用来存储每张卡的一个标识位。这个标识位代表对应的卡是否可能存有指向新生代对象的引用。如果可能存在，那么就认为这张卡是脏的。

在进行Minor GC的时候，便可以不用扫描整个老年代，而是在卡表中寻找脏卡，并将脏卡中的对象加入到Minor GC的GC Roots里，当完成所有脏卡的扫描之后，JVM便会将所有脏卡的标识位清零。
