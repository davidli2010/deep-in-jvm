## 垃圾回收（上）

*免费的其实是最贵的*

## 引用计数与可达性分析

在JVM语境下，垃圾指的是死亡的对象所占据的堆空间。这里便涉及了一个关键的问题：如何辨别一个对象是存是亡？

引用计数法（reference counting）的做法是为每个对象添加一个引用计数器，用来统计指向该对象的引用个数。一旦某个对象的引用计数器为0，则说明该对象已经死亡，便可以被回收了。

除了需要额外的空间来存储计数器，以及繁琐的更新操作，引用计数法还有一个重大的漏洞，那便是无法处理循环引用对象。

目前JVM的主流垃圾回收器采取的是可达性分析算法。这个算法的实质在于将一系列GC Roots作为初始的存储对象集合（live set），然后从该集合出发，探索所有能够被该集合引用到的对象，并将其加入到该集合中，这个过程也称之为标记（mark）。最终，未被探索到的对象便是死亡的，是可以回收的。

一般而言，GC Roots包括（但不限于）如下几种：
1. Java方法栈帧中的局部变量；
2. 已加载类的静态变量；
3. JNI handles；
4. 已启动且未停止的Java线程。

可达性分析可以解决引用计数法所不能解决的循环引用问题。

## Stop-the-world以及安全点

在JVM里，传统的垃圾回收算法采用的是一种简单粗暴的方式，那便是Stop-the-world，停止其它非垃圾回收线程的工作，直到完成垃圾回收。这也造成了垃圾回收所谓的暂停时间（GC pause）。

JVM中的Stop-the-world是通过安全点（safepoint）机制来实现的。当JVM收到Stop-the-world请求，它便会等待所有的线程都到达安全点，才允许请求Stop-the-world的线程进行独占的工作。

## 垃圾回收的三种方式

当标记完所有的存储对象时，便可以进行死亡对象的回收工作了。主流的基础回收方式可分为三种。

第一种是清除（sweep），即把死亡的对象所占据的内存标记为空闲内存，并记录在一个空闲列表（free list）之中。当需要新建对象时，内存管理模块便会从该空闲列表中寻找空闲内存，并划分给新建的对象。缺点是会造成内存碎片和分配效率较低。

第二种是压缩（compact），即把存活的对象聚集到内存区域的起始位置，从而留下一段连续的内存空间。这种做法能够解决内存碎片化的问题，但代价是压缩算法的性能开销。

第三种则是复制（copy），即把内存区域分为两等分，分别用两个指针from和to来维护，并且只是用from指针指向的内存区域来分配内存。当发生垃圾回收时，便把存活的对象复制到to指针指向的内存区域中，并且交换from指针和to指针的内容。这种回收方式同样能够解决内存碎片化的问题，但是它的缺点也极其明显，即堆空间的使用效率极其低下。

现代的垃圾回收器往往综合上述几种回收方式，综合它们优点的同时规避它们的缺点。
