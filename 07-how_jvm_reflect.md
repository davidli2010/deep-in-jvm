# JVM如何实现反射

反射是Java语言中相当重要的特性，它允许正在运行的Java程序观测，甚至是修改程序的动态行为。

## 反射调用的实现

Method.invoke实际上委派给MethodAccessor来处理。MethodAccessor是一个接口，它有两个已有的具体实现：一个通过本地方法来实现反射调用，另一个则使用了委派模式。

每个Method实例的第一次反射调用都会生成一个委派实现，它所委派的具体实现便是一个本地实现。本地实现非常容易理解。当进入了JVM内部之后，我们便拥有了Method实例所指向方法的具体地址。这时候，反射调用无非就是将传入的参数准备好，然后调用进入目标方法。

为什么反射调用机制还要采取委派实现作为中间层？直接交给本地实现不可以么？

Java的反射调用机制还设立了另一种动态生成字节码的实现，直接使用invoke指令来调用目标方法。之所以采用委派实现，便是为了能够在本地实现以及动态实现之间切换。

## 反射调用的开销

第一，由于Method.invoke是一个变长参数方法，在字节码层面它的最后一个参数会是Object数组。Java编译器会在方法调用处生成一个长度为传入参数数量的Object数组，并将传入参数一一存储进该数组中。

第二，由于Object数组不能存储基本类型，Java编译器会对传入的基本类型参数进行自动装箱。

这两个操作除了带来性能开销外，还可能占用堆内存，使得GC更加频繁。
