# JVM如何实现synchronized？

当声明synchronized代码块时，编译而成的字节码将包含monitorenter和mointorexit指令。这两种指令均会消耗操作数栈上的一个引用类型的元素（也就是synchronized关键字括号里的引用），作为所要加锁解锁的锁对象。

当用synchronized标记方法时，你会看到字节码中方法的访问标记包括ACC_SYNCHRONIZED。该标记表示在进入该方法时，JVM需要进行monitorenter操作。而在退出该方法时，不管是正常返回，还是向调用者抛异常，JVM均需要进行monitorexit操作。

关于monitorenter和monitorexit的作用，我们可以抽象地理解为每个锁对象拥有一个锁计数器和一个指向持有该锁的线程的指针。

## 重量级锁

重量级锁是JVM中最为基础的锁实现。在这种状态下，JVM会阻塞加锁失败的线程，并且在目标锁被释放的时候，唤醒这些线程。

Java线程的阻塞以及唤醒，都是依靠操作系统来完成的。为了尽量避免昂贵的线程阻塞、唤醒操作，JVM会在线程进入阻塞状态之前，以及被唤醒后竞争不到锁的情况下，进入自旋状态，在处理器上空跑并且轮询锁是否被释放。如果此时锁恰好被释放了，那么当前线程便无须进入阻塞状态，而是直接获得这把锁。

## 轻量级锁

多个线程在不同的时间段请求同一把锁，也就是说没有锁竞争。针对这种情形，JVM采用了轻量级锁，来避免重量级锁的阻塞以及唤醒。

当进行加锁操作时，JVM会判断是否已经是重量级锁。如果不是，它会在当前线程的当前栈帧中划出一块空间，作为该锁的锁记录，并且将锁对象的标记字段复制到该锁记录中。然后，JVM会尝试用CAS操作替换锁对象的标记字段。

## 偏向锁

偏向锁针对的情况更加乐观：从始至终只有一个线程请求某一把锁。

在线程进行加锁时，如果该锁对象支持偏向锁，那么JVM会通过CAS操作，将当前线程的地址记录在锁对象的标记字段之中，并且将标记字段的最后三位设置为101。

在接下来的运行过程中，每当有线程请求这把锁，JVM只需判断锁对象标记字段中最后三位是否为101，是否包含当前线程的地址，以及epoch值是否和锁对象的类的epoch值相同。如果都满足，那么当前线程持有该偏向锁，可以直接返回。

